data = readmatrix('map_points.csv');
n=360;

% Extract columns
X = data(:,1);
Y = data(:,2);

Xr = data(:,3);
Yr = data(:,4);
Thetar = data(:,5);

% Plot points

figure;
hold on;
scatter(X, Y, 5, 'filled');
axis equal;
xlabel('X (m)');
ylabel('Y (m)');
title('Lidar Map Points');
grid on;
hold off;

% scan matching

sz=floor(size(data,1)/n);

scans=zeros(sz,n,4);
odometry = zeros(sz,3);

for i=1:sz
    scans(i,:,:)=data((-359+360*i):(360*i),1:4);
    odometry(i,:)=data(360*i,6:8);
end


% occupancy map

map = occupancyMap(12,12,20);
map.GridLocationInWorld = [-6 -6];

poseList = zeros(sz,3);
poseList(1,:) = odometry(1,:);
keyInterval = 5;
loopClosureScoreThresh = 0.95;

keyScans = {};
keyScanPoses = [];

% Loop through all the scans and calculate the relative poses between them
for idx = 2:sz
    % Process the data in pairs.
    referenceScan = lidarScan(squeeze(scans(idx-1,:,3:4)));
    currentScan = lidarScan(squeeze(scans(idx,:,3:4)));

    deltaOdom = odometry(idx,:)-odometry(idx-1,:); %from webots odometry data
    
    % Run scan matching. Note that the scan angles stay the same and do 
    % not have to be recomputed. To increase accuracy, set the maximum 
    % number of iterations to 500. Use the transform from the last
    % iteration as the initial estimate.
    [transform,stats] = matchScans(currentScan,referenceScan, ...
        MaxIterations=500,InitialPose=deltaOdom);

    fusedDelta = scanTform;
    
    % Maintain the list of robot poses. 
    absolutePose = composeTransform(poseList(idx-1,:),transform);
    poseList(idx,:) = absolutePose;
       
    % Integrate the current laser scan into the probabilistic occupancy
    % grid.
    insertRay(map,absolutePose,currentScan,10);

    %store key scans
    if mod(idx, keyInterval) == 0
        keyScans{end+1} = currentScan;
        keyScanPoses(end+1,:) = poseList(idx,:);
    end

    %{ 
    loop closure detection
    for k = 1:length(keyScans)-1
        [tformLC, statsLC] = matchScans(currentScan, keyScans{k}, ...
            'MaxIterations', 100);
        
        if statsLC.Score > loopClosureScoreThresh
            disp("Loop closure detected between scan " + idx + ...
                 " and key scan " + k + ...
                 " | Score = " + statsLC.Score);

            % Snap current pose to matched key pose
            poseList(idx,:) = composeTransform(keyScanPoses(k,:), tformLC);
        end
    end
    %}

    show(map);
    drawnow;
end





function newPose = composeTransform(oldPose, tform)
    % oldPose: [x, y, theta]
    % tform: [dx, dy, dtheta] in meters, radians
    
    dx = tform(1);
    dy = tform(2);
    dtheta = tform(3);

    % Rotate translation into world frame
    rot = [cos(oldPose(3)) -sin(oldPose(3));
           sin(oldPose(3))  cos(oldPose(3))];
    transWorld = (rot * [dx; dy])';

    % Update pose
    newPose = [ ...
        oldPose(1) + transWorld(1), ...
        oldPose(2) + transWorld(2), ...
        oldPose(3) + dtheta ...
    ];
end

%{
[1] P. Biber, W. Strasser, "The normal distributions transform: A new approach to laser scan matching," 
in Proceedings of IEEE/RSJ International Conference on Intelligent Robots and Systems (IROS), 2003, pp. 2743-2748
%}